{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>\u0412 \u044d\u0442\u043e\u043c \u043f\u0440\u043e\u0435\u043a\u0442\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432\u0441\u0435 \u043b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b, \u043f\u043e \u043f\u0440\u0435\u0434\u043c\u0435\u0442\u0443 Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435. \u0412\u044b\u043f\u043e\u043b\u043d\u044f\u043b \u0440\u0430\u0431\u043e\u0442\u044b \u0441\u0442\u0443\u0434\u0435\u043d\u0442 \u0433\u0440\u0443\u043f\u043f\u044b \u041a3340 \u0420\u0443\u0441\u0438\u043d\u043e\u0432 \u0412\u0430\u0441\u0438\u043b\u0438\u0439.</p>"},{"location":"Lr1/db/","title":"\u041a\u043e\u0434 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 \u0411\u0414","text":"<p>\u0424\u0430\u0439\u043b <code>connection.py</code></p> <pre><code>import os\n\nfrom dotenv import load_dotenv\nfrom sqlmodel import SQLModel, Session, create_engine\n\nload_dotenv()\ndb_url = os.getenv('DB_URL')\nengine = create_engine(db_url, echo=True)\nprint(\"DB_URL =\", db_url)\n\ndef init_db():\n    SQLModel.metadata.create_all(engine)\n\ndef get_session():\n    with Session(engine) as session:\n        yield session\n</code></pre>"},{"location":"Lr1/endpoints/","title":"\u0412\u0441\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d\u043d\u044b\u0435 \u044d\u043d\u0434\u043f\u043e\u0438\u043d\u0442\u044b","text":"<p>\u0424\u0430\u0439\u043b <code>tag_endpoints.py</code></p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlmodel import Session, select\nfrom db.connection import get_session\nfrom models.models import Tag\nfrom models.tag import TagCreate, TagRead\n\ntag_router = APIRouter(prefix=\"/tags\", tags=[\"Tags\"])\n\n\n@tag_router.post(\"/\", response_model=TagRead)\ndef create_tag(tag: TagCreate, session: Session = Depends(get_session)):\n    db_tag = Tag(name=tag.name)\n    session.add(db_tag)\n    session.commit()\n    session.refresh(db_tag)\n    return db_tag\n\n\n@tag_router.get(\"/\", response_model=list[TagRead])\ndef get_tags(session: Session = Depends(get_session)):\n    return session.exec(select(Tag)).all()\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>task_endpoints.py</code></p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlmodel import Session, select\nfrom db.connection import get_session\nfrom endpoints.user_endpoints import auth_handler\nfrom models.models import Task, Tag, TaskTag\nfrom models.task import TaskCreate, TaskRead\nfrom models.models import User\ntask_router = APIRouter(prefix=\"/tasks\", tags=[\"Tasks\"])\n\n\n@task_router.post(\"/\", response_model=TaskRead)\ndef create_task(task: TaskCreate, session: Session = Depends(get_session), current_user: User = Depends(auth_handler.get_current_user)):\n\n    db_task = Task(\n        title=task.title,\n        description=task.description,\n        deadline=task.deadline,\n        priority=task.priority,\n        owner_id=current_user.id\n    )\n    session.add(db_task)\n    session.commit()\n    session.refresh(db_task)\n\n    for tag_id in task.tag_ids:\n        link = TaskTag(task_id=db_task.id, tag_id=tag_id)\n        session.add(link)\n\n    session.commit()\n    return db_task\n\n\n@task_router.get(\"/\", response_model=list[TaskRead])\ndef get_all_tasks(session: Session = Depends(get_session)):\n    return session.exec(select(Task)).all()\n\n\n@task_router.get(\"/{task_id}\", response_model=TaskRead)\ndef get_task(task_id: int, session: Session = Depends(get_session)):\n    task = session.get(Task, task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    return task\n\n\n@task_router.delete(\"/{task_id}\")\ndef delete_task(task_id: int, session: Session = Depends(get_session)):\n    task = session.get(Task, task_id)\n    if not task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    session.delete(task)\n    session.commit()\n    return {\"detail\": \"Task deleted\"}\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>timelog_endpoints.py</code></p> <pre><code>from fastapi import APIRouter, Depends, HTTPException\nfrom sqlmodel import Session, select\nfrom db.connection import get_session\nfrom models.models import TimeLog\nfrom models.timelog import TimeLogCreate, TimeLogRead\n\ntimelog_router = APIRouter(prefix=\"/timelogs\", tags=[\"TimeLogs\"])\n\n\n@timelog_router.post(\"/\", response_model=TimeLogRead)\ndef create_log(log: TimeLogCreate, session: Session = Depends(get_session)):\n    db_log = TimeLog(**log.dict())\n    session.add(db_log)\n    session.commit()\n    session.refresh(db_log)\n    return db_log\n\n\n@timelog_router.get(\"/task/{task_id}\", response_model=list[TimeLogRead])\ndef get_logs_for_task(task_id: int, session: Session = Depends(get_session)):\n    return session.exec(select(TimeLog).where(TimeLog.task_id == task_id)).all()\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>user_endpoints.py</code></p> <pre><code>from fastapi import APIRouter, HTTPException, Depends\nfrom sqlmodel import Session, select\nfrom starlette.responses import JSONResponse\nfrom starlette.status import HTTP_201_CREATED\nfrom typing_extensions import List\n\nfrom auth.auth import AuthHandler\nfrom models.models import User\nfrom models.user import UserCreate, UserLogin, UserRead, UserPasswordChange\nfrom db.connection import get_session\nfrom repos.user_repos import select_all_users, find_user\n\nuser_router = APIRouter()\nauth_handler = AuthHandler()\n\n\n@user_router.post('/registration', status_code=201, tags=['users'],\n                  description='Register new user')\ndef register(user: UserCreate, session=Depends(get_session)):\n    users = select_all_users()\n    if any(u.email == user.email for u in users):\n        raise HTTPException(status_code=400, detail='Email is taken')\n    hashed_pwd = auth_handler.get_password_hash(user.password)\n    u = User(email=user.email, password=hashed_pwd, name=user.name, phone=user.phone, role=user.role)\n    session.add(u)\n    session.commit()\n    return JSONResponse(status_code=HTTP_201_CREATED, content={\"Message\": \"User Registered\"})\n\n\n@user_router.post('/login', tags=['users'])\ndef login(user: UserLogin):\n    user_found = find_user(user.email)\n    if not user_found:\n        raise HTTPException(status_code=401, detail='Invalid email and/or password')\n    verified = auth_handler.verify_password(user.password, user_found.password)\n    if not verified:\n        raise HTTPException(status_code=401, detail='Invalid email and/or password')\n    token = auth_handler.encode_token(user_found.email)\n    return {'token': token}\n\n\n@user_router.get('/users/me', tags=['users'])\ndef get_current_user(user: User = Depends(auth_handler.get_current_user)):\n    return user\n\n\n@user_router.get(\"/users\", response_model=List[UserRead], tags=['users'])\ndef get_users(session: Session = Depends(get_session)):\n    return session.exec(select(User)).all()\n\n\n@user_router.post(\"/change-password\", tags=['users'])\ndef change_password(\n        data: UserPasswordChange,\n        session: Session = Depends(get_session),\n        current_user: User = Depends(auth_handler.get_current_user)\n):\n    if not auth_handler.verify_password(data.old_password, current_user.password):\n        raise HTTPException(status_code=400, detail=\"Incorrect old password\")\n\n    current_user.password = auth_handler.get_password_hash(data.new_password)\n    session.add(current_user)\n    session.commit()\n    return {\"message\": \"Password updated successfully\"}\n</code></pre>"},{"location":"Lr1/models/","title":"\u041c\u043e\u0434\u0435\u043b\u0438","text":"<p>\u0424\u0430\u0439\u043b <code>models.py</code></p> <pre><code>from datetime import datetime\nfrom enum import Enum\nfrom typing import Optional, List\n\nfrom pydantic import EmailStr\nfrom sqlmodel import SQLModel, Field, Relationship\n\n\n\nclass UserRole(Enum):\n    user = \"user\"\n    admin = \"admin\"\n\nclass PriorityLevel(Enum):\n    low = \"low\"\n    medium = \"medium\"\n    high = \"high\"\n    critical = \"critical\"\n\n\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n    email: EmailStr\n    password: str\n    phone: str\n    role: UserRole = UserRole.user\n\n    tasks: List[\"Task\"] = Relationship(back_populates=\"owner\")\n\n\nclass TaskTag(SQLModel, table=True):\n    task_id: int = Field(foreign_key=\"task.id\", primary_key=True)\n    tag_id: int = Field(foreign_key=\"tag.id\", primary_key=True)\n    relevance: Optional[str] = \"general\"\n\n\nclass Tag(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    name: str\n\n    tasks: List[\"Task\"] = Relationship(back_populates=\"tags\", link_model=TaskTag)\n\n\nclass Task(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    title: str\n    description: Optional[str] = None\n    deadline: Optional[datetime] = None\n    priority: PriorityLevel = PriorityLevel.medium\n    owner_id: int = Field(foreign_key=\"user.id\")\n\n    owner: Optional[User] = Relationship(back_populates=\"tasks\")\n    tags: List[Tag] = Relationship(back_populates=\"tasks\", link_model=TaskTag)\n    time_logs: List[\"TimeLog\"] = Relationship(back_populates=\"task\")\n\n\nclass TimeLog(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True)\n    task_id: int = Field(foreign_key=\"task.id\")\n    start_time: datetime\n    end_time: Optional[datetime] = None\n\n    task: Optional[Task] = Relationship(back_populates=\"time_logs\")\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>tag.py</code></p> <pre><code>from sqlmodel import SQLModel\n\n\nclass TagCreate(SQLModel):\n    name: str\n\n\nclass TagRead(SQLModel):\n    id: int\n    name: str\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>task.py</code></p> <pre><code>from datetime import datetime\n\nfrom typing import Optional, List\nfrom sqlmodel import SQLModel, Field\nfrom models.models import PriorityLevel\nfrom models.tag import TagRead\n\n\nclass TaskCreate(SQLModel):\n    title: str\n    description: Optional[str] = None\n    deadline: Optional[datetime] = None\n    priority: PriorityLevel = PriorityLevel.medium\n    tag_ids: Optional[List[int]] = []\n\n\nclass TaskRead(SQLModel):\n    id: int\n    title: str\n    description: Optional[str]\n    deadline: Optional[datetime]\n    priority: PriorityLevel\n    owner_id: int\n    tags: List[TagRead]\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>timelog.py</code></p> <pre><code>from datetime import datetime\n\nfrom sqlmodel import SQLModel\nfrom typing import Optional\n\n\nclass TimeLogCreate(SQLModel):\n    task_id: int\n    start_time: str\n    end_time: Optional[str] = None\n\n\nclass TimeLogRead(SQLModel):\n    id: int\n    task_id: int\n    start_time: datetime\n    end_time: Optional[datetime] = None\n</code></pre> <p>\u0424\u0430\u0439\u043b <code>user.py</code></p> <pre><code>from typing import Optional\n\nfrom pydantic import EmailStr\nfrom sqlmodel import SQLModel, Field\n\nfrom models.models import UserRole\n\n\nclass UserCreate(SQLModel):\n    name: str\n    email: EmailStr\n    password: str = Field(max_length=256, min_length=6)\n    phone: str\n    role: UserRole\n\n\nclass UserPatch(SQLModel):\n    name: Optional[str] = None\n    email: Optional[EmailStr] = None\n    phone: Optional[str] = None\n    role: Optional[UserRole] = UserRole.user\n\n\nclass UserLogin(SQLModel):\n    email: EmailStr\n    password: str\n\n\nclass UserReadShort(SQLModel):\n    id: int\n    name: str\n\n\nclass UserRead(SQLModel):\n    id: int\n    name: str\n    email: str\n    phone: str\n    role: UserRole\n\n\nclass UserPasswordChange(SQLModel):\n    old_password: str\n    new_password: str\n</code></pre>"}]}